# automatically generated by the FlatBuffers compiler, do not modify

# namespace: rknn

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Graph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Graph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GraphBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x4B\x4E\x4E", size_prefixed=size_prefixed)

    # Graph
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Graph
    def Tensors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from rknncli.schema.rknn.Tensor import Tensor
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def TensorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def TensorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Graph
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from rknncli.schema.rknn.Node import Node
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Graph
    def Inputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Graph
    def InputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def InputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Graph
    def Outputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Graph
    def OutputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def OutputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Graph
    def Var1(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from rknncli.schema.rknn.Type2 import Type2
            obj = Type2()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def Var1Length(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def Var1IsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def GraphStart(builder):
    builder.StartObject(5)

def Start(builder):
    GraphStart(builder)

def GraphAddTensors(builder, tensors):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(tensors), 0)

def AddTensors(builder, tensors):
    GraphAddTensors(builder, tensors)

def GraphStartTensorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTensorsVector(builder, numElems):
    return GraphStartTensorsVector(builder, numElems)

def GraphAddNodes(builder, nodes):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)

def AddNodes(builder, nodes):
    GraphAddNodes(builder, nodes)

def GraphStartNodesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartNodesVector(builder, numElems):
    return GraphStartNodesVector(builder, numElems)

def GraphAddInputs(builder, inputs):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def AddInputs(builder, inputs):
    GraphAddInputs(builder, inputs)

def GraphStartInputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartInputsVector(builder, numElems):
    return GraphStartInputsVector(builder, numElems)

def GraphAddOutputs(builder, outputs):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def AddOutputs(builder, outputs):
    GraphAddOutputs(builder, outputs)

def GraphStartOutputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartOutputsVector(builder, numElems):
    return GraphStartOutputsVector(builder, numElems)

def GraphAddVar1(builder, var1):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(var1), 0)

def AddVar1(builder, var1):
    GraphAddVar1(builder, var1)

def GraphStartVar1Vector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartVar1Vector(builder, numElems):
    return GraphStartVar1Vector(builder, numElems)

def GraphEnd(builder):
    return builder.EndObject()

def End(builder):
    return GraphEnd(builder)

import rknncli.schema.rknn.Node
import rknncli.schema.rknn.Tensor
import rknncli.schema.rknn.Type2
try:
    from typing import List
except:
    pass

class GraphT(object):

    # GraphT
    def __init__(
        self,
        tensors = None,
        nodes = None,
        inputs = None,
        outputs = None,
        var1 = None,
    ):
        self.tensors = tensors  # type: Optional[List[rknn.Tensor.TensorT]]
        self.nodes = nodes  # type: Optional[List[rknn.Node.NodeT]]
        self.inputs = inputs  # type: Optional[List[int]]
        self.outputs = outputs  # type: Optional[List[int]]
        self.var1 = var1  # type: Optional[List[rknn.Type2.Type2T]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        graph = Graph()
        graph.Init(buf, pos)
        return cls.InitFromObj(graph)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, graph):
        x = GraphT()
        x._UnPack(graph)
        return x

    # GraphT
    def _UnPack(self, graph):
        if graph is None:
            return
        if not graph.TensorsIsNone():
            self.tensors = []
            for i in range(graph.TensorsLength()):
                if graph.Tensors(i) is None:
                    self.tensors.append(None)
                else:
                    tensor_ = rknn.Tensor.TensorT.InitFromObj(graph.Tensors(i))
                    self.tensors.append(tensor_)
        if not graph.NodesIsNone():
            self.nodes = []
            for i in range(graph.NodesLength()):
                if graph.Nodes(i) is None:
                    self.nodes.append(None)
                else:
                    node_ = rknn.Node.NodeT.InitFromObj(graph.Nodes(i))
                    self.nodes.append(node_)
        if not graph.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(graph.InputsLength()):
                    self.inputs.append(graph.Inputs(i))
            else:
                self.inputs = graph.InputsAsNumpy()
        if not graph.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(graph.OutputsLength()):
                    self.outputs.append(graph.Outputs(i))
            else:
                self.outputs = graph.OutputsAsNumpy()
        if not graph.Var1IsNone():
            self.var1 = []
            for i in range(graph.Var1Length()):
                if graph.Var1(i) is None:
                    self.var1.append(None)
                else:
                    type2_ = rknn.Type2.Type2T.InitFromObj(graph.Var1(i))
                    self.var1.append(type2_)

    # GraphT
    def Pack(self, builder):
        if self.tensors is not None:
            tensorslist = []
            for i in range(len(self.tensors)):
                tensorslist.append(self.tensors[i].Pack(builder))
            GraphStartTensorsVector(builder, len(self.tensors))
            for i in reversed(range(len(self.tensors))):
                builder.PrependUOffsetTRelative(tensorslist[i])
            tensors = builder.EndVector()
        if self.nodes is not None:
            nodeslist = []
            for i in range(len(self.nodes)):
                nodeslist.append(self.nodes[i].Pack(builder))
            GraphStartNodesVector(builder, len(self.nodes))
            for i in reversed(range(len(self.nodes))):
                builder.PrependUOffsetTRelative(nodeslist[i])
            nodes = builder.EndVector()
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                GraphStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                GraphStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        if self.var1 is not None:
            var1list = []
            for i in range(len(self.var1)):
                var1list.append(self.var1[i].Pack(builder))
            GraphStartVar1Vector(builder, len(self.var1))
            for i in reversed(range(len(self.var1))):
                builder.PrependUOffsetTRelative(var1list[i])
            var1 = builder.EndVector()
        GraphStart(builder)
        if self.tensors is not None:
            GraphAddTensors(builder, tensors)
        if self.nodes is not None:
            GraphAddNodes(builder, nodes)
        if self.inputs is not None:
            GraphAddInputs(builder, inputs)
        if self.outputs is not None:
            GraphAddOutputs(builder, outputs)
        if self.var1 is not None:
            GraphAddVar1(builder, var1)
        graph = GraphEnd(builder)
        return graph
